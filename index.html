<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#050816">
  <title>SpaceMathe ‚Äì Franziskas Mathe im Weltraum</title>
  <style>
    :root {
      --bg:#050816; --panel:#0b1230; --txt:#eaf2ff; --muted:#b9d6ff; --accent:#5ad6ff;
      --danger:#ff5b7a; --ok:#1fe3a2;
      --safe-top: env(safe-area-inset-top, 0);
      --safe-bottom: env(safe-area-inset-bottom, 0);
      --safe-left: env(safe-area-inset-left, 0);
      --safe-right: env(safe-area-inset-right, 0);
    }
    html, body {
      margin:0; padding:0;
      min-height:100vh; min-height:100dvh;
      height:100%;
      background:var(--bg); overflow:hidden; touch-action:manipulation;
      box-sizing:border-box;
      padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    }
    *, *::before, *::after { box-sizing: inherit; }
    canvas {
      display:block;
      position:fixed;
      top: var(--safe-top); left: var(--safe-left);
      right: var(--safe-right); bottom: var(--safe-bottom);
      width: calc(100vw - var(--safe-left) - var(--safe-right));
      height: calc(100vh - var(--safe-top) - var(--safe-bottom));
      height: calc(100dvh - var(--safe-top) - var(--safe-bottom));
    }
    * { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }

    .overlay {
      position:fixed;
      top: var(--safe-top); left: var(--safe-left); right: var(--safe-right); bottom: var(--safe-bottom);
      display:flex; align-items:flex-end; justify-content:center;
      padding:0 20px 20px; box-sizing:border-box;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(90,214,255,.12), rgba(5,8,22,.94));
      color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Arial;
      overflow-y: auto;
      transition: opacity 0.25s ease;
    }
    .overlay.cockpit-enter .card {
      transform: translateY(120%);
      opacity: 0;
    }
    .overlay .card {
      width:min(540px, 94vw);
      max-width:100%;
      background: rgba(11,18,48,.95);
      border: 1px solid rgba(127,168,255,.3);
      border-radius: 20px;
      padding: 20px 18px;
      box-shadow: 0 20px 50px rgba(0,0,0,.5);
      transition: transform 0.45s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.4s ease-out;
      transform: translateY(0);
      opacity: 1;
    }
    .overlay.cockpit-exit .card {
      transform: translateY(120%);
      opacity: 0;
      transition: transform 0.35s cubic-bezier(0.55, 0, 0.9, 0.4), opacity 0.3s ease-in;
    }
    .title {
      font-size: 32px; font-weight: 800; letter-spacing:.02em;
      display:flex; gap:10px; align-items:center; justify-content:center;
      margin: 4px 0 4px;
    }
    .subtitle {
      text-align:center; color:var(--muted); margin: 0 0 14px; font-size: 14px;
    }
    .section { margin: 14px 0; }
    .section h3 { font-size: 14px; color: var(--accent); margin: 0 0 8px; text-transform: uppercase; letter-spacing:.06em; }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; margin: 8px 0; }
    .row label { font-size: 15px; color:var(--txt); }
    .row .val { font-variant-numeric: tabular-nums; color:var(--accent); min-width: 56px; text-align:right; }
    input[type="range"] { width: 58%; }
    .checkrow { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin: 8px 0; }
    .checkrow label { display:flex; align-items:center; gap:8px; font-size: 15px; cursor:pointer; }
    .checkrow input[type="checkbox"] { width:20px; height:20px; accent-color: var(--accent); }
    .reihchips { display:flex; flex-wrap:wrap; gap:6px; margin-top: 6px; }
    .reihchips label { display:flex; align-items:center; gap:4px; font-size: 13px; cursor:pointer; padding: 6px 10px; border-radius: 999px;
      background: rgba(5,8,22,.6); border: 1px solid rgba(127,168,255,.25); color: var(--muted); }
    .reihchips label:has(input:checked) { background: rgba(90,214,255,.2); border-color: rgba(90,214,255,.5); color: var(--txt); }
    .reihchips input { width: 16px; height: 16px; accent-color: var(--accent); }
    select, button {
      font: inherit; border-radius: 12px; border: 1px solid rgba(127,168,255,.3);
      background: rgba(5,8,22,.8); color: var(--txt); padding: 10px 12px;
    }
    button {
      width:100%; margin-top: 14px; background: linear-gradient(180deg, rgba(90,214,255,.35), rgba(90,214,255,.18));
      border-color: rgba(90,214,255,.5);
      font-weight: 700;
      padding: 14px 16px;
      font-size: 18px;
    }
    button:active { transform: translateY(1px); }
    .btn-secondary {
      margin: 0; padding: 8px 14px; font-size: 13px;
      background: rgba(127, 168, 255, 0.15);
      border-color: rgba(127, 168, 255, 0.4);
      width: auto; font-weight: 600;
    }
    .chips { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top: 12px; }
    .chip {
      font-size: 12px; color: var(--muted);
      border: 1px solid rgba(127,168,255,.25);
      border-radius: 999px; padding: 6px 10px;
      background: rgba(5,8,22,.55);
    }
    .tiny { text-align:center; color:#6c85c7; font-size: 12px; margin-top: 12px; }
    .hidden { display:none !important; }
    .game-buttons {
      position: fixed;
      bottom: calc(16px + var(--safe-bottom));
      left: var(--safe-left); right: var(--safe-right);
      display: flex; gap: 12px; justify-content: center; padding: 0 16px;
      z-index: 10; pointer-events: none;
    }
    .game-buttons button {
      pointer-events: auto;
      flex: 1; max-width: 180px;
      margin: 0; padding: 12px 16px; font-size: 15px;
      background: rgba(11, 18, 48, 0.9);
      border: 1px solid rgba(127, 168, 255, 0.4);
      border-radius: 12px;
      color: var(--txt);
    }
    .game-buttons button:active { transform: scale(0.98); }
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -8px); }
      12% { opacity: 1; transform: translate(-50%, 0); }
      88% { opacity: 1; transform: translate(-50%, 0); }
      100% { opacity: 0; transform: translate(-50%, -4px); }
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="gameButtons" class="game-buttons hidden">
  <button type="button" id="btnPause">‚è∏ Pause</button>
  <button type="button" id="btnQuit">üè† Startbildschirm</button>
</div>

<div id="menu" class="overlay">
  <div class="card">
    <div class="title">üöÄ SpaceMathe</div>
    <p class="subtitle">Franziskas Mathe im Weltraum ‚Äì Einmaleins, Plus & Minus √ºber 10</p>

    <div class="section">
      <h3>Was √ºben?</h3>
      <div class="checkrow">
        <label><input type="checkbox" id="cfgMul" checked /> Einmaleins (1√ó1)</label>
        <label><input type="checkbox" id="cfgAdd" /> Addition √ºber 10</label>
        <label><input type="checkbox" id="cfgSub" /> Subtraktion √ºber 10</label>
      </div>
    </div>

    <div class="section" id="reihSection">
      <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px; margin-bottom:8px;">
        <h3 style="margin:0;">Einmaleins-Reihen (Level)</h3>
        <button type="button" id="btnSelectAll" class="btn-secondary">Alles markieren</button>
      </div>
      <div class="reihchips" id="reihChips">
        <label><input type="checkbox" name="reih" value="2" /> 2er</label>
        <label><input type="checkbox" name="reih" value="3" /> 3er</label>
        <label><input type="checkbox" name="reih" value="4" checked /> 4er</label>
        <label><input type="checkbox" name="reih" value="5" /> 5er</label>
        <label><input type="checkbox" name="reih" value="6" /> 6er</label>
        <label><input type="checkbox" name="reih" value="7" /> 7er</label>
        <label><input type="checkbox" name="reih" value="8" /> 8er</label>
        <label><input type="checkbox" name="reih" value="9" /> 9er</label>
        <label><input type="checkbox" name="reih" value="10" /> 10er</label>
      </div>
    </div>

    <div class="row">
      <label for="speed">Geschwindigkeit</label>
      <input id="speed" type="range" min="1" max="10" step="1" value="2" />
      <div class="val" id="speedVal">2/10</div>
    </div>
    <div class="row">
      <label for="answers">Antworten</label>
      <select id="answers">
        <option value="3">3 Antworten</option>
        <option value="4">4 Antworten</option>
      </select>
      <div class="val" id="answersVal">3</div>
    </div>
    <div class="row">
      <label for="ramp">Steigerung</label>
      <select id="ramp">
        <option value="on" selected>an</option>
        <option value="off">aus</option>
      </select>
      <div class="val" id="rampVal">an</div>
    </div>

    <div class="chips">
      <span class="chip">‚úÖ richtig = Warp-Boost</span>
      <span class="chip">‚ùå falsch = Schild-Treffer</span>
      <span class="chip">‚≠ê Bestwert wird gespeichert</span>
    </div>

    <button id="startBtn">Start</button>
    <div class="tiny">iPad: Safari ‚Üí Teilen ‚Üí ‚ÄûZum Home-Bildschirm‚Äú ‚Äì dann wie eine App</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const menu = document.getElementById('menu');
  const speedEl = document.getElementById('speed');
  const answersEl = document.getElementById('answers');
  const rampEl = document.getElementById('ramp');
  const startBtn = document.getElementById('startBtn');
  const speedVal = document.getElementById('speedVal');
  const answersVal = document.getElementById('answersVal');
  const rampVal = document.getElementById('rampVal');
  const cfgMul = document.getElementById('cfgMul');
  const cfgAdd = document.getElementById('cfgAdd');
  const cfgSub = document.getElementById('cfgSub');

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => a + Math.random() * (b - a);
  const randi = (a,b) => Math.floor(rand(a, b + 1));

  // ‚Äî‚Äî Resize (iPad/WebApp: Canvas passt sich angezeigter Fl√§che an, safe-area per CSS) ‚Äî‚Äî
  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    let cw = Math.floor(rect.width);
    let ch = Math.floor(rect.height);
    if (cw <= 0 || ch <= 0) {
      cw = window.innerWidth;
      ch = window.innerHeight;
    }
    cw = Math.max(300, cw);
    ch = Math.max(400, ch);
    const w = cw * dpr;
    const h = ch * dpr;
    canvas.width = w; canvas.height = h;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
    state.dpr = dpr;
    state.w = w;
    state.h = h;
  }
  window.addEventListener('resize', resize, { passive: true });
  if (window.visualViewport) window.visualViewport.addEventListener('resize', resize, { passive: true });
  window.addEventListener('orientationchange', () => setTimeout(resize, 150), { passive: true });

  function roundedRectPath(x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // ‚Äî‚Äî Sound (Web Audio, synthetisch) ‚Äî‚Äî
  let audioCtx = null;
  function getAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  }
  function playTone(freq, duration, type = 'sine', volume = 0.15) {
    try {
      const ctx = getAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.value = freq;
      osc.type = type;
      gain.gain.setValueAtTime(volume, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + duration);
    } catch (e) {}
  }
  function soundCorrect() {
    playTone(523, 0.12, 'sine', 0.2);
    setTimeout(() => playTone(659, 0.1, 'sine', 0.15), 80);
    setTimeout(() => playTone(784, 0.15, 'sine', 0.18), 160);
  }
  function soundWrong() {
    playTone(220, 0.2, 'sawtooth', 0.12);
    setTimeout(() => playTone(180, 0.25, 'sawtooth', 0.1), 100);
  }
  function soundLevelIntro() {
    playTone(440, 0.08, 'sine', 0.18);
    setTimeout(() => playTone(554, 0.08, 'sine', 0.16), 90);
    setTimeout(() => playTone(659, 0.15, 'sine', 0.2), 180);
  }
  function soundGameOver() {
    playTone(330, 0.25, 'sawtooth', 0.15);
    setTimeout(() => playTone(262, 0.4, 'sawtooth', 0.12), 150);
  }
  function soundCombo() {
    playTone(523, 0.06, 'sine', 0.18);
    setTimeout(() => playTone(659, 0.06, 'sine', 0.18), 60);
    setTimeout(() => playTone(784, 0.08, 'sine', 0.2), 120);
    setTimeout(() => playTone(1047, 0.12, 'sine', 0.16), 180);
  }

  // ‚Äî‚Äî State ‚Äî‚Äî
  const state = {
    w: 0, h: 0, dpr: 1,
    phase: 'menu', // menu | levelIntro | play | paused | gameover
    lastT: 0,
    stars: [],
    capsules: [],
    particles: [],
    warpLines: [],
    shakeT: 0,
    flashT: 0,
    score: 0,
    best: 0,
    combo: 0,
    shield: 3,
    wave: 0,
    task: null,
    levelIntroT: 0,
    levelTitle: '',
    blockIndex: 0,
    correctInBlock: 0,
    CORRECT_PER_BLOCK: 4,
    LEVEL_INTRO_MS: 2200,
    blocks: [],       // { type: 'mul'|'addZehner'|'subZehner', row?: 2..10, title }
    rampOn: true,
    baseTimeLimit: 10000,
    baseSpeed: 0.08,
    optionCount: 3,
    recent: [],
    ship: { x: 0, y: 0, r: 26 },
    bgVariant: 0,
    floatTexts: [],   // { x, y, text, life, t, vy, scale, color }
    comboPopupT: 0,  // Combo-Banner Anzeige
    sparkles: [],    // kleine Sterne/Bling
    shipTrail: [],   // { x, y, life, t } f√ºr Combo-Trail
    milestoneT: 0,
    milestoneText: '',
    lastMilestone: 0,
    gameTime: 0,
    warpTunnel: [],   // { angle, dist, speed } radial vom Zentrum
    comets: [],       // { angle, dist, len, speed, alpha } Sternschnuppen
    cometCooldown: 0,
    checkboxesLocked: true,
    unlockClickCount: 0,
    unlockClickTime: 0,
  };

  try { state.best = Number(localStorage.getItem('spacemathe_best') || 0) || 0; } catch (e) {}

  const gameButtons = document.getElementById('gameButtons');
  const btnPause = document.getElementById('btnPause');
  const btnQuit = document.getElementById('btnQuit');
  const btnSelectAll = document.getElementById('btnSelectAll');

  function showMenuCockpitIn() {
    ensureLockedReihState();
    menu.classList.remove('hidden');
    menu.classList.add('cockpit-enter');
    requestAnimationFrame(() => {
      requestAnimationFrame(() => { menu.classList.remove('cockpit-enter'); });
    });
  }

  function hideMenuCockpitOut(done) {
    menu.classList.add('cockpit-exit');
    setTimeout(() => {
      menu.classList.add('hidden');
      menu.classList.remove('cockpit-exit');
      if (done) done();
    }, 380);
  }

  resize();
  initWarpTunnel();
  menu.classList.add('cockpit-enter');
  requestAnimationFrame(() => {
    requestAnimationFrame(() => { menu.classList.remove('cockpit-enter'); });
  });

  function buildBlocks() {
    const blocks = [];
    if (cfgMul.checked) {
      if (state.checkboxesLocked) {
        for (let row = 2; row <= 10; row++) blocks.push({ type: 'mul', row, title: `${row}er-Reihe` });
      } else {
        document.querySelectorAll('.reihchips input[name="reih"]:checked').forEach(cb => {
          const row = Number(cb.value);
          blocks.push({ type: 'mul', row, title: `${row}er-Reihe` });
        });
      }
    }
    if (cfgAdd.checked) blocks.push({ type: 'addZehner', title: 'Addition √ºber 10' });
    if (cfgSub.checked) blocks.push({ type: 'subZehner', title: 'Subtraktion √ºber 10' });
    if (blocks.length === 0) {
      blocks.push({ type: 'mul', row: 2, title: '2er-Reihe' });
    }
    state.blocks = blocks;
  }

  function applySettingsFromUI() {
    const speed = Number(speedEl.value);
    const options = Number(answersEl.value);
    const rampOn = rampEl.value === 'on';
    // Deutlich langsamer: Speed 1 = sehr gem√ºtlich (~10s), 10 = moderat (~5s)
    const tl = 10000 - (speed - 1) * 550;
    const bs = 0.08 + (speed - 1) * (0.22/9);
    state.baseTimeLimit = tl;
    state.baseSpeed = bs;
    state.optionCount = options;
    state.rampOn = rampOn;
    buildBlocks();
  }

  function updateMenuLabels() {
    speedVal.textContent = `${speedEl.value}/10`;
    answersVal.textContent = answersEl.value;
    rampVal.textContent = rampEl.value === 'on' ? 'an' : 'aus';
  }

  [speedEl, answersEl, rampEl].forEach(el => {
    el.addEventListener('input', () => { applySettingsFromUI(); updateMenuLabels(); }, { passive: true });
    el.addEventListener('change', () => { applySettingsFromUI(); updateMenuLabels(); }, { passive: true });
  });
  [cfgMul, cfgAdd, cfgSub].forEach(el => {
    el.addEventListener('change', () => { applySettingsFromUI(); }, { passive: true });
  });

  document.querySelectorAll('.reihchips input[name="reih"]').forEach(el => {
    el.addEventListener('change', function() {
      if (state.checkboxesLocked && !this.checked) {
        this.checked = true;
        return;
      }
      applySettingsFromUI();
    }, { passive: true });
  });

  const reihSection = document.getElementById('reihSection');
  reihSection.addEventListener('click', (e) => {
    const now = Date.now();
    if (now - state.unlockClickTime > 15000) state.unlockClickCount = 0;
    state.unlockClickCount++;
    state.unlockClickTime = now;
    if (state.unlockClickCount >= 3) {
      state.checkboxesLocked = false;
      state.unlockClickCount = 0;
      playTone(523, 0.1, 'sine', 0.2);
      setTimeout(() => playTone(659, 0.1, 'sine', 0.2), 120);
      setTimeout(() => playTone(784, 0.15, 'sine', 0.22), 240);
      showBackdoorFeedback();
    }
    if (!state.checkboxesLocked) applySettingsFromUI();
  }, { passive: true });

  function showBackdoorFeedback() {
    const el = document.createElement('div');
    el.id = 'backdoorFeedback';
    el.setAttribute('style', 'position:absolute;left:50%;transform:translateX(-50%);top:12px;background:rgba(30,180,120,0.95);color:#fff;padding:10px 18px;border-radius:12px;font-size:14px;font-weight:700;z-index:100;box-shadow:0 4px 20px rgba(0,0,0,.4);animation:fadeInOut 2.5s ease forwards;');
    el.textContent = 'Reihen frei w√§hlbar';
    const card = document.querySelector('#menu .card');
    if (card) {
      card.style.position = 'relative';
      card.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.remove(); }, 2500);
    }
  }

  btnSelectAll.addEventListener('click', (e) => {
    e.preventDefault();
    cfgMul.checked = true;
    cfgAdd.checked = true;
    cfgSub.checked = true;
    document.querySelectorAll('.reihchips input[name="reih"]').forEach(cb => { cb.checked = true; });
    if (!state.checkboxesLocked) applySettingsFromUI();
    updateMenuLabels();
  }, { passive: false });

  function ensureLockedReihState() {
    if (!state.checkboxesLocked) return;
    cfgMul.checked = true;
    document.querySelectorAll('.reihchips input[name="reih"]').forEach(cb => { cb.checked = true; });
  }

  ensureLockedReihState();
  applySettingsFromUI();
  updateMenuLabels();

  // ‚Äî‚Äî Stars (with variant) ‚Äî‚Äî
  function initStars() {
    state.stars.length = 0;
    const n = Math.floor((state.w * state.h) / 200000);
    const count = clamp(n, 80, 260);
    for (let i = 0; i < count; i++) {
      state.stars.push({
        x: Math.random() * state.w,
        y: Math.random() * state.h,
        z: rand(0.2, 1.0),
        s: rand(0.6, 2.4) * state.dpr,
      });
    }
  }
  initStars();
  window.addEventListener('resize', initStars, { passive: true });

  function initWarpTunnel() {
    state.warpTunnel.length = 0;
    const numSpokes = 36;
    const maxDist = Math.max(state.w, state.h) * 0.85;
    for (let i = 0; i < numSpokes; i++) {
      const angle = (i / numSpokes) * Math.PI * 2 + rand(0, 0.1);
      state.warpTunnel.push({
        angle,
        dist: Math.random() * maxDist,
        speed: rand(0.8, 1.6) * state.dpr * (1 + state.w / 800),
      });
    }
    const numRings = 12;
    for (let i = 0; i < numRings; i++) {
      state.warpTunnel.push({
        angle: -1,
        dist: Math.random() * maxDist * 0.5,
        speed: rand(0.6, 1.4) * state.dpr * (1 + state.w / 800),
      });
    }
  }
  window.addEventListener('resize', initWarpTunnel, { passive: true });

  function placeShip() {
    state.ship.x = state.w * 0.5;
    state.ship.y = state.h - (88 * state.dpr);
    state.ship.r = 26 * state.dpr;
  }
  placeShip();
  window.addEventListener('resize', placeShip, { passive: true });

  function haptic(type) {
    try {
      if (navigator.vibrate) navigator.vibrate(type === 'heavy' ? 20 : 10);
    } catch (e) {}
  }

  // ‚Äî‚Äî Task generators ‚Äî‚Äî
  function pickTask() {
    const blocks = state.blocks;
    if (!blocks.length) return { text: '1 √ó 1', ans: 1, type: 'mul' };
    const block = blocks[state.blockIndex % blocks.length];
    if (block.type === 'mul') {
      const a = block.row;
      const b = randi(1, 10);
      const ans = a * b;
      return { a, b, ans, text: `${a} √ó ${b}`, type: 'mul' };
    }
    if (block.type === 'addZehner') {
      const a = randi(2, 9);
      const need = 11 - a;
      const b = randi(need, 9);
      if (a + b < 11) return pickTask();
      const ans = a + b;
      return { a, b, ans, text: `${a} + ${b}`, type: 'add' };
    }
    if (block.type === 'subZehner') {
      const ans = randi(3, 9);
      const bMin = Math.max(1, 11 - ans);
      const bMax = Math.min(9, 18 - ans);
      if (bMin > bMax) return pickTask();
      const b = randi(bMin, bMax);
      const a = ans + b;
      return { a, b, ans, text: `${a} ‚àí ${b}`, type: 'sub' };
    }
    return pickTask();
  }

  function makeOptions(correct, task) {
    const opts = new Set([correct]);
    const plausible = [
      correct + randi(-3, 3),
      correct + randi(-5, 5),
      correct + randi(-2, 2),
    ];
    if (task && (task.type === 'mul' || task.a)) {
      if (task.type === 'mul') {
        plausible.push((task.a - 1) * task.b, (task.a + 1) * task.b, task.a * (task.b - 1), task.a * (task.b + 1));
      }
      plausible.push(correct + 1, correct - 1, correct + 10, correct - 10);
    }
    const pick = () => {
      let v = plausible[randi(0, plausible.length - 1)];
      if (!Number.isFinite(v)) v = correct + randi(-9, 9);
      v = Math.abs(Math.round(v));
      v = clamp(v, 0, 100);
      if (v === correct && Math.random() < 0.6) v = clamp(correct + randi(-8, 8), 0, 100);
      return v;
    };
    while (opts.size < state.optionCount) {
      let v = pick();
      if (v === correct) continue;
      opts.add(v);
    }
    const arr = Array.from(opts);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function spawnWave() {
    state.wave++;
    state.task = pickTask();
    const options = makeOptions(state.task.ans, state.task);

    const cx = state.w / 2;
    const cy = state.h * 0.48;
    const count = options.length;
    const baseR = (32 + (count === 4 ? -2 : 0)) * 3 * state.dpr;
    const minGap = baseR * 2.2;
    const marginX = Math.max(50 * state.dpr, minGap * 0.6);
    const minX = marginX;
    const maxX = state.w - marginX;
    const step = Math.max((maxX - minX) / count, minGap);
    const originSpreadX = 50 * state.dpr;
    const originSpreadY = 38 * state.dpr;

    const bandGap = minGap / state.h;
    const bandTop = 0.18;
    const bandRange = (count - 1) * bandGap;
    const bandBottom = Math.min(0.88, bandTop + bandRange);
    const bandStep = count > 1 ? (bandBottom - bandTop) / (count - 1) : 0;

    state.capsules.length = 0;
    for (let i = 0; i < count; i++) {
      const laneCenter = minX + step * (i + 0.5);
      const jitterX = rand(-6, 6) * state.dpr;
      const laneX = clamp(laneCenter + jitterX, minX, maxX);
      const laneY = state.h * (bandTop + i * bandStep + rand(-0.01, 0.01));
      state.capsules.push({
        laneX, laneY,
        cx, cy,
        originOffsetX: rand(-originSpreadX, originSpreadX),
        originOffsetY: rand(-originSpreadY, originSpreadY),
        r: baseR * rand(0.95, 1.05),
        value: options[i],
        correct: options[i] === state.task.ans,
        approachT: 0,
        speedFactor: rand(0.88, 1.12),
      });
    }
  }

  function getCapsuleDisplay(c) {
    const progress = Math.min(1, c.approachT / state.timeLimit);
    const scale = 0.30 + 0.70 * progress;
    const ox = c.cx + (c.originOffsetX || 0);
    const oy = c.cy + (c.originOffsetY || 0);
    const x = ox + (c.laneX - ox) * scale;
    const y = oy + (c.laneY - oy) * scale;
    return { x, y, scale };
  }

  function nextBlock() {
    state.blockIndex++;
    state.correctInBlock = 0;
    state.bgVariant = (state.bgVariant + 1) % 3;
    state.levelTitle = state.blocks[state.blockIndex % state.blocks.length].title;
    state.levelIntroT = state.LEVEL_INTRO_MS;
    state.phase = 'levelIntro';
    soundLevelIntro();
  }

  const MOTIVATIONAL = ['Super!', 'Mega!', 'Weiter so!', 'Spitze!', 'Klasse!', 'Toll!', 'Yes!', 'Stark!', 'Genau!', 'Top!'];

  const MAX_PARTICLES = 280;
  const MAX_SPARKLES = 120;
  const MAX_FLOAT_TEXTS = 40;

  function addFloatText(x, y, text, color = '#9cffd8') {
    if (state.floatTexts.length >= MAX_FLOAT_TEXTS) state.floatTexts.shift();
    state.floatTexts.push({
      x, y, text, color,
      life: 1100, t: 0, vy: -0.35 * state.dpr,
      scale: 1.2 + Math.random() * 0.3,
    });
  }

  function addSparkles(x, y, count = 12) {
    while (state.sparkles.length + count > MAX_SPARKLES && state.sparkles.length > 0) state.sparkles.shift();
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const dist = rand(15, 55) * state.dpr;
      state.sparkles.push({
        x: x + Math.cos(a) * dist * 0.3,
        y: y + Math.sin(a) * dist * 0.3,
        vx: Math.cos(a) * 0.15 * state.dpr,
        vy: Math.sin(a) * 0.15 * state.dpr - 0.2 * state.dpr,
        life: rand(400, 800), t: 0,
        s: rand(2, 5) * state.dpr,
        hue: rand(40, 180),
      });
    }
  }

  function burst(x, y, good = true) {
    const n = good ? 72 : 32;
    while (state.particles.length + n > MAX_PARTICLES && state.particles.length > 0) state.particles.shift();
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = (good ? rand(0.35, 1.4) : rand(0.2, 0.85)) * state.dpr;
      state.particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: good ? rand(500, 1100) : rand(350, 650),
        t: 0,
        good,
      });
    }
    if (good) addSparkles(x, y, 14);
  }

  function addWarpLines() {
    const n = 6 + state.combo * 2;
    for (let i = 0; i < n; i++) {
      state.warpLines.push({
        x: state.w * (0.3 + Math.random() * 0.4),
        y: state.h + rand(0, 60),
        w: rand(2, 8) * state.dpr,
        len: rand(50, 130) * state.dpr,
        vy: -rand(0.8, 2.2) * state.dpr,
        life: rand(250, 550),
        t: 0,
      });
    }
  }

  function screenShake(ms = 260) { state.shakeT = ms; }
  function screenFlash(ms = 180) { state.flashT = ms; }

  function recordResult(ok) {
    state.recent.push(ok);
    if (state.recent.length > 12) state.recent.shift();
  }

  function updateDifficulty() {
    if (!state.rampOn) return;
    const w = state.wave;
    const target = state.baseTimeLimit - w * 25;
    state.timeLimit = clamp(target, 4500, state.baseTimeLimit);
    state.speed = clamp((state.baseSpeed + w * 0.0008), 0.08, 0.45) * state.dpr;
    const r = state.recent;
    if (r.length >= 8) {
      const acc = r.filter(Boolean).length / r.length;
      if (acc < 0.55) state.timeLimit = clamp(state.timeLimit + 400, 5000, state.baseTimeLimit + 800);
      else if (acc > 0.88) state.timeLimit = clamp(state.timeLimit - 150, 4000, state.baseTimeLimit);
    }
  }

  function resetGame() {
    state.score = 0;
    state.combo = 0;
    state.shield = 3;
    state.wave = 0;
    state.recent.length = 0;
    state.capsules.length = 0;
    state.particles.length = 0;
    state.warpLines.length = 0;
    state.comets.length = 0;
    state.cometCooldown = 0;
    state.floatTexts.length = 0;
    state.sparkles.length = 0;
    state.comboPopupT = 0;
    state.shipTrail.length = 0;
    state.milestoneT = 0;
    state.lastMilestone = 0;
    state.blockIndex = 0;
    state.correctInBlock = 0;
    state.bgVariant = Math.floor(Math.random() * 3);
    state.timeLimit = state.baseTimeLimit;
    state.speed = state.baseSpeed * state.dpr;
    applySettingsFromUI();
    buildBlocks();
    state.levelTitle = state.blocks[0].title;
    state.levelIntroT = state.LEVEL_INTRO_MS;
    state.phase = 'levelIntro';
    soundLevelIntro();
    placeShip();
    gameButtons.classList.remove('hidden');
  }

  function gameOver() {
    state.phase = 'gameover';
    state.capsules.length = 0;
    state.combo = 0;
    gameButtons.classList.add('hidden');
    for (let i = 0; i < 40; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = rand(0.2, 0.8) * state.dpr;
      state.particles.push({
        x: state.w/2, y: state.h/2,
        vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
        life: rand(600, 1200), t: 0, good: false,
      });
    }
    soundGameOver();
    if (state.score > state.best) {
      state.best = state.score;
      try { localStorage.setItem('spacemathe_best', String(state.best)); } catch (e) {}
    }
  }

  // ‚Äî‚Äî Input ‚Äî‚Äî
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * state.dpr,
      y: (e.clientY - rect.top) * state.dpr,
    };
  }

  function handleTap(x, y) {
    if (state.phase === 'levelIntro') return;
    if (state.phase === 'paused') return;
    if (state.phase === 'play') {
      for (let i = 0; i < state.capsules.length; i++) {
        const c = state.capsules[i];
        const d = getCapsuleDisplay(c);
        const hitR = c.r * d.scale;
        const dx = x - d.x, dy = y - d.y;
        if (dx*dx + dy*dy <= hitR*hitR) {
          if (c.correct) {
            const points = 10 + state.combo * 2;
            state.score += points;
            state.combo++;
            recordResult(true);
            state.correctInBlock++;
            burst(d.x, d.y, true);
            addFloatText(d.x, d.y - hitR, '+' + points, '#b8ffdd');
            if (state.combo >= 2) {
              addWarpLines();
              state.comboPopupT = 600;
              for (let i = 0; i < 5; i++) state.shipTrail.push({ x: state.ship.x, y: state.ship.y, life: 400 + i * 80, t: 0 });
              if (state.combo >= 5) {
                state.milestoneT = 900;
                state.milestoneText = 'MEGA COMBO!';
              }
              if (state.combo >= 3) soundCombo();
              else soundCorrect();
              addFloatText(d.x, d.y - hitR - 30, MOTIVATIONAL[randi(0, MOTIVATIONAL.length - 1)], '#ffeb6b');
            } else soundCorrect();
            const nextMs = [50, 100, 150, 200, 300, 500];
            const idx = nextMs.findIndex(m => state.score >= m && state.lastMilestone < m);
            if (idx >= 0) {
              state.lastMilestone = nextMs[idx];
              state.milestoneT = 800;
              state.milestoneText = nextMs[idx] + ' Punkte!';
            }
            haptic(state.combo >= 3 ? 'heavy' : 'light');
            addSparkles(d.x, d.y, state.combo >= 3 ? 22 : 14);
            screenFlash(state.combo >= 3 ? 180 : 120);
            for (const other of state.capsules) {
              if (!other.correct) { const od = getCapsuleDisplay(other); burst(od.x, od.y, true); }
            }
            state.capsules.length = 0;
            updateDifficulty();
            if (state.correctInBlock >= state.CORRECT_PER_BLOCK) {
              nextBlock();
            } else {
              spawnWave();
            }
          } else {
            burst(d.x, d.y, false);
            recordResult(false);
            state.combo = 0;
            state.shield--;
            screenShake(320);
            soundWrong();
            haptic('heavy');
            if (state.shield <= 0) gameOver();
            else {
              state.capsules.length = 0;
              updateDifficulty();
              spawnWave();
            }
          }
          return;
        }
      }
    } else if (state.phase === 'gameover') {
      state.phase = 'menu';
      showMenuCockpitIn();
    }
  }

  btnPause.addEventListener('click', (e) => {
    e.preventDefault();
    if (state.phase === 'play') {
      state.phase = 'paused';
      btnPause.textContent = '‚ñ∂ Weiter';
    } else if (state.phase === 'paused') {
      state.phase = 'play';
      btnPause.textContent = '‚è∏ Pause';
    }
  }, { passive: false });

  btnQuit.addEventListener('click', (e) => {
    e.preventDefault();
    state.phase = 'menu';
    gameButtons.classList.add('hidden');
    btnPause.textContent = '‚è∏ Pause';
    showMenuCockpitIn();
  }, { passive: false });

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    handleTap(getPointerPos(e).x, getPointerPos(e).y);
  }, { passive: false });

  startBtn.addEventListener('click', (e) => {
    e.preventDefault();
    applySettingsFromUI();
    updateMenuLabels();
    hideMenuCockpitOut(() => { resetGame(); });
  }, { passive: false });

  // ‚Äî‚Äî Update ‚Äî‚Äî
  function update(dt) {
    for (const s of state.stars) {
      s.y += (0.04 + 0.2 * s.z) * dt * state.dpr;
      if (s.y > state.h + 10) { s.y = -10; s.x = Math.random() * state.w; }
    }

    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.992;
      p.vy *= 0.992;
      if (p.t > p.life) state.particles.splice(i, 1);
    }

    for (let i = state.warpLines.length - 1; i >= 0; i--) {
      const w = state.warpLines[i];
      w.t += dt;
      w.y += w.vy * dt;
      if (w.t > w.life) state.warpLines.splice(i, 1);
    }

    for (let i = state.floatTexts.length - 1; i >= 0; i--) {
      const f = state.floatTexts[i];
      f.t += dt;
      f.y += f.vy * dt;
      if (f.t > f.life) state.floatTexts.splice(i, 1);
    }

    for (let i = state.sparkles.length - 1; i >= 0; i--) {
      const s = state.sparkles[i];
      s.t += dt;
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.vy *= 0.98;
      if (s.t > s.life) state.sparkles.splice(i, 1);
    }

    if (state.comboPopupT > 0) state.comboPopupT = Math.max(0, state.comboPopupT - dt);
    if (state.milestoneT > 0) state.milestoneT = Math.max(0, state.milestoneT - dt);
    state.gameTime += dt;

    for (let i = state.shipTrail.length - 1; i >= 0; i--) {
      state.shipTrail[i].t += dt;
      if (state.shipTrail[i].t > state.shipTrail[i].life) state.shipTrail.splice(i, 1);
    }

    const maxTunnelDist = Math.max(state.w, state.h) * 0.92;
    for (const sp of state.warpTunnel) {
      sp.dist += sp.speed * dt;
      if (sp.dist > maxTunnelDist) sp.dist = 0;
    }

    state.cometCooldown = Math.max(0, state.cometCooldown - dt);
    if (state.cometCooldown <= 0 && state.comets.length < 2 && Math.random() < 0.0008 * dt) {
      state.cometCooldown = 1800 + Math.random() * 2500;
      const angle = Math.random() * Math.PI * 2;
      state.comets.push({
        angle,
        dist: rand(0, 40) * state.dpr,
        len: rand(35, 80) * state.dpr,
        speed: rand(4, 8) * state.dpr,
        alpha: rand(0.4, 0.75),
      });
    }
    for (let i = state.comets.length - 1; i >= 0; i--) {
      const co = state.comets[i];
      co.dist += co.speed * dt;
      if (co.dist > maxTunnelDist + 100) state.comets.splice(i, 1);
    }

    if (state.phase === 'paused') return;

    if (state.phase === 'levelIntro') {
      state.levelIntroT -= dt;
      if (state.levelIntroT <= 0) {
        state.phase = 'play';
        spawnWave();
      }
      if (state.shakeT > 0) state.shakeT = Math.max(0, state.shakeT - dt);
      if (state.flashT > 0) state.flashT = Math.max(0, state.flashT - dt);
      return;
    }

    if (state.phase === 'play') {
      for (let i = 0; i < state.capsules.length; i++) {
        const c = state.capsules[i];
        c.approachT += dt * (c.speedFactor || 1);
        const d = getCapsuleDisplay(c);
        c.x = d.x; c.y = d.y; c.scale = d.scale;
      }
      for (let i = state.capsules.length - 1; i >= 0; i--) {
        const c = state.capsules[i];
        if (c.approachT >= state.timeLimit) {
          recordResult(false);
          state.combo = 0;
          state.shield--;
          screenShake(380);
          burst(c.x, c.y, false);
          soundWrong();
          state.capsules.length = 0;
          if (state.shield <= 0) gameOver();
          else { updateDifficulty(); spawnWave(); }
          break;
        }
      }
    }

    if (state.shakeT > 0) state.shakeT = Math.max(0, state.shakeT - dt);
    if (state.flashT > 0) state.flashT = Math.max(0, state.flashT - dt);
  }

  function drawWarpTunnel() {
    const cx = state.w / 2;
    const cy = state.h * 0.5;
    const maxD = Math.max(state.w, state.h) * 0.9;
    for (const sp of state.warpTunnel) {
      if (sp.angle < 0) {
        const r = sp.dist;
        const alpha = 0.03 + 0.08 * (1 - r / maxD);
        ctx.strokeStyle = `rgba(100, 160, 220, ${alpha})`;
        ctx.lineWidth = 1.2 * state.dpr;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        const dist = sp.dist;
        const x2 = cx + Math.cos(sp.angle) * dist;
        const y2 = cy + Math.sin(sp.angle) * dist;
        const alpha = 0.025 + 0.11 * (1 - dist / maxD);
        ctx.strokeStyle = `rgba(160, 200, 235, ${alpha})`;
        ctx.lineWidth = Math.max(0.8, (0.8 + 1 * (1 - dist / (state.w * 0.8))) * state.dpr);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    for (const co of state.comets) {
      const x1 = cx + Math.cos(co.angle) * (co.dist - co.len);
      const y1 = cy + Math.sin(co.angle) * (co.dist - co.len);
      const x2 = cx + Math.cos(co.angle) * co.dist;
      const y2 = cy + Math.sin(co.angle) * co.dist;
      const a = co.alpha * (1 - co.dist / (maxD * 1.1));
      ctx.strokeStyle = `rgba(255, 255, 255, ${a})`;
      ctx.lineWidth = (2.5 + 1.5 * (1 - co.dist / maxD)) * state.dpr;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.strokeStyle = `rgba(200, 230, 255, ${a * 0.7})`;
      ctx.lineWidth = 1.2 * state.dpr;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawCockpitVignette() {
    const g = ctx.createRadialGradient(
      state.w/2, state.h/2, state.w * 0.2,
      state.w/2, state.h/2, state.w * 0.9
    );
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(0.6, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, state.w, state.h);
    ctx.strokeStyle = 'rgba(90, 214, 255, 0.12)';
    ctx.lineWidth = 2 * state.dpr;
    ctx.strokeRect(8 * state.dpr, 8 * state.dpr, state.w - 16*state.dpr, state.h - 16*state.dpr);
  }

  function drawBackground() {
    const v = state.bgVariant;
    if (v === 0) {
      ctx.fillStyle = '#050816';
      ctx.fillRect(0, 0, state.w, state.h);
    } else if (v === 1) {
      const g = ctx.createLinearGradient(0, 0, 0, state.h);
      g.addColorStop(0, '#0a0e2a');
      g.addColorStop(0.5, '#151a3a');
      g.addColorStop(1, '#050816');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, state.w, state.h);
    } else {
      const g = ctx.createRadialGradient(state.w/2, state.h*0.3, 0, state.w/2, state.h, state.w*0.8);
      g.addColorStop(0, '#1a0a2e');
      g.addColorStop(0.6, '#0d0618');
      g.addColorStop(1, '#050816');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, state.w, state.h);
    }
    const starColor = v === 0 ? '#cfe3ff' : v === 1 ? '#b8d4ff' : '#d4c8ff';
    ctx.fillStyle = starColor;
    for (const s of state.stars) {
      const a = 0.2 + 0.6 * s.z;
      ctx.globalAlpha = a;
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.globalAlpha = 1;
  }

  function drawHeart(cx, cy, r) {
    ctx.fillStyle = '#ff5b7a';
    ctx.beginPath();
    ctx.moveTo(cx, cy + r*0.35);
    ctx.bezierCurveTo(cx + r*1.1, cy - r*0.7, cx + r*2, cy + r*0.8, cx, cy + r*1.8);
    ctx.bezierCurveTo(cx - r*2, cy + r*0.8, cx - r*1.1, cy - r*0.7, cx, cy + r*0.35);
    ctx.fill();
  }

  function drawLevelIntro() {
    const t = 1 - state.levelIntroT / state.LEVEL_INTRO_MS;
    const pulse = 0.85 + 0.15 * Math.sin(state.levelIntroT * 0.008);
    ctx.save();
    ctx.globalAlpha = (0.4 + 0.6 * Math.min(1, t * 2)) * pulse;
    ctx.fillStyle = '#eaf2ff';
    ctx.font = `bold ${Math.floor(40 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(90, 214, 255, 0.8)';
    ctx.shadowBlur = 25 * state.dpr;
    ctx.fillText(state.levelTitle, state.w/2, state.h/2);
    ctx.shadowBlur = 0;
    ctx.restore();
    for (let i = 0; i < 8; i++) {
      const a = (state.levelIntroT * 0.002 + i * Math.PI / 4) % (Math.PI * 2);
      const r = 80 * state.dpr + Math.sin(state.levelIntroT * 0.005) * 15 * state.dpr;
      ctx.globalAlpha = 0.5 * (1 - t);
      ctx.fillStyle = '#5ad6ff';
      ctx.beginPath();
      ctx.arc(state.w/2 + Math.cos(a) * r, state.h/2 + Math.sin(a) * r, 4 * state.dpr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawTaskInSpace() {
    if (state.phase !== 'play' || !state.task) return;
    const cx = state.w / 2;
    const ty = 88 * state.dpr;
    const taskStr = state.task.text + ' = ?';
    const fontSize = Math.floor(72 * state.dpr);
    ctx.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.85)';
    ctx.shadowBlur = 14 * state.dpr;
    ctx.strokeStyle = 'rgba(90, 214, 255, 0.5)';
    ctx.lineWidth = 4 * state.dpr;
    ctx.strokeText(taskStr, cx, ty);
    ctx.fillStyle = '#eaf2ff';
    ctx.fillText(taskStr, cx, ty);
    ctx.shadowBlur = 0;
  }

  function drawHUD() {
    const pad = 16 * state.dpr;
    const top = 10 * state.dpr;
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = '#0b1230';
    roundedRectPath(pad, top, state.w - pad*2, 86 * state.dpr, 16 * state.dpr);
    ctx.fill();
    ctx.globalAlpha = 1;

    const hx = state.w - pad*1.6;
    const hy = top + 43*state.dpr;
    const r = 10*state.dpr;
    for (let i = 0; i < 3; i++) {
      ctx.globalAlpha = (i < state.shield) ? 1 : 0.25;
      drawHeart(hx - i*(26*state.dpr), hy, r);
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#b9d6ff';
    ctx.font = `${Math.floor(18 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    const comboText = state.combo >= 2 ? ` Combo x${state.combo}` : '';
    ctx.fillText(`Score ${state.score}${comboText}`, pad*1.6, top + 78*state.dpr);

    ctx.textAlign = 'right';
    ctx.fillStyle = '#7fa8ff';
    ctx.fillText(state.blocks[state.blockIndex % state.blocks.length]?.title || '', state.w - pad*1.6, top + 78*state.dpr);
    ctx.textAlign = 'left';
  }

  function drawShip() {
    const { x, y, r } = state.ship;
    const idleY = Math.sin(state.gameTime * 0.002) * 3 * state.dpr;
    const drawY = y + idleY;
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#5ad6ff';
    ctx.beginPath();
    ctx.arc(x, drawY, r*1.4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#eaf2ff';
    ctx.beginPath();
    ctx.moveTo(x, drawY - r);
    ctx.lineTo(x + r*0.9, drawY + r*0.9);
    ctx.lineTo(x, drawY + r*0.45);
    ctx.lineTo(x - r*0.9, drawY + r*0.9);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#0b1230';
    ctx.beginPath();
    ctx.arc(x, drawY - r*0.15, r*0.35, 0, Math.PI*2);
    ctx.fill();

    const flame = clamp(6 + state.combo*1.3, 6, 20) * state.dpr;
    ctx.fillStyle = '#ffd36a';
    ctx.beginPath();
    ctx.moveTo(x, drawY + r*0.9);
    ctx.lineTo(x + r*0.25, drawY + r*0.9 + flame);
    ctx.lineTo(x, drawY + r*0.9 + flame*0.75);
    ctx.lineTo(x - r*0.25, drawY + r*0.9 + flame);
    ctx.closePath();
    ctx.fill();
  }

  function drawCapsule(c) {
    const scale = c.scale || getCapsuleDisplay(c).scale;
    const px = c.x;
    const py = c.y;
    const pulse = c.approachT > state.timeLimit - 1400
      ? 0.6 + 0.4 * Math.sin(c.approachT * 0.012)
      : 1;
    ctx.save();
    ctx.translate(px, py);
    ctx.scale(scale, scale);
    ctx.translate(-px, -py);
    ctx.shadowColor = c.correct ? 'rgba(30, 230, 160, 0.6)' : 'rgba(90, 214, 255, 0.45)';
    ctx.shadowBlur = 10 * state.dpr;
    ctx.globalAlpha = 0.95 * pulse;
    ctx.fillStyle = '#2b4cff';
    ctx.beginPath();
    ctx.arc(px, py, c.r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.88;
    ctx.fillStyle = '#0b1230';
    ctx.beginPath();
    ctx.arc(px, py, c.r*0.82, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#eaf2ff';
    ctx.shadowBlur = 0;
    ctx.font = `${Math.floor(c.r*0.9)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(c.value), px, py + 1*state.dpr);

    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(px - c.r*0.25, py - c.r*0.3, c.r*0.35, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawWarpLines() {
    ctx.strokeStyle = 'rgba(90, 214, 255, 0.5)';
    ctx.lineCap = 'round';
    for (const w of state.warpLines) {
      ctx.globalAlpha = 1 - w.t / w.life;
      ctx.lineWidth = w.w;
      ctx.beginPath();
      ctx.moveTo(w.x, w.y);
      ctx.lineTo(w.x, w.y - w.len);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawGameOver() {
    const cx = state.w/2, cy = state.h/2;
    ctx.fillStyle = '#eaf2ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${Math.floor(44 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillText('GAME OVER', cx, cy - 78*state.dpr);
    ctx.font = `${Math.floor(22 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillStyle = '#b9d6ff';
    ctx.fillText(`Score: ${state.score}`, cx, cy - 20*state.dpr);
    ctx.fillText(`Best: ${state.best}`, cx, cy + 16*state.dpr);
    ctx.fillStyle = '#7fa8ff';
    ctx.font = `${Math.floor(16 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillText('Tippe f√ºr Startbildschirm', cx, cy + 66*state.dpr);
  }

  function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    ctx.clearRect(0, 0, state.w, state.h);

    drawBackground();
    drawWarpTunnel();

    if (state.flashT > 0) {
      const flashAlpha = 0.2 * (state.flashT / 180);
      ctx.fillStyle = state.combo >= 3
        ? `rgba(255, 235, 100, ${flashAlpha * 0.7})`
        : `rgba(255, 255, 255, ${flashAlpha})`;
      ctx.fillRect(0, 0, state.w, state.h);
    }

    if (state.shakeT > 0) {
      const k = state.shakeT / 380;
      ctx.save();
      ctx.translate((Math.random()*2-1)*10*k*state.dpr, (Math.random()*2-1)*10*k*state.dpr);
    }

    drawWarpLines();
    for (const tr of state.shipTrail) {
      const k = 1 - tr.t / tr.life;
      ctx.globalAlpha = k * 0.6;
      ctx.fillStyle = '#5ad6ff';
      ctx.beginPath();
      ctx.arc(tr.x, tr.y, state.ship.r * (0.4 + 0.4 * k), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    drawHUD();
    drawTaskInSpace();
    drawShip();
    for (const c of state.capsules) drawCapsule(c);

    for (const p of state.particles) {
      const t = p.t / p.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = p.good ? '#9cffd8' : '#ff7a7a';
      ctx.beginPath();
      ctx.arc(p.x, p.y, (2.5 + (p.good ? 1.5 : 0.8)) * state.dpr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    for (const s of state.sparkles) {
      const t = s.t / s.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = `hsl(${s.hue}, 90%, 70%)`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    for (const f of state.floatTexts) {
      const t = f.t / f.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = f.color;
      ctx.font = `bold ${Math.floor(18 * state.dpr * f.scale)}px system-ui, -apple-system, Segoe UI, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(f.text, f.x, f.y);
    }
    ctx.globalAlpha = 1;

    if (state.comboPopupT > 0 && state.combo >= 2) {
      const k = state.comboPopupT / 600;
      const scale = 1 + (1 - k) * 0.3;
      ctx.save();
      ctx.globalAlpha = k;
      ctx.translate(state.w/2, state.h * 0.32);
      ctx.scale(scale, scale);
      ctx.fillStyle = '#ffeb6b';
      ctx.strokeStyle = '#5ad6ff';
      ctx.lineWidth = 4 * state.dpr;
      ctx.font = `bold ${Math.floor(42 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeText('COMBO x' + state.combo + '!', 0, 0);
      ctx.fillText('COMBO x' + state.combo + '!', 0, 0);
      ctx.restore();
    }

    if (state.milestoneT > 0) {
      const k = state.milestoneT / 800;
      ctx.save();
      ctx.globalAlpha = k <= 0.3 ? k / 0.3 : (k >= 0.7 ? (1 - k) / 0.3 : 1);
      ctx.fillStyle = '#ffd700';
      ctx.strokeStyle = '#5ad6ff';
      ctx.lineWidth = 3 * state.dpr;
      ctx.font = `bold ${Math.floor(36 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeText(state.milestoneText, state.w/2, state.h * 0.38);
      ctx.fillText(state.milestoneText, state.w/2, state.h * 0.38);
      ctx.restore();
    }

    if (state.phase === 'levelIntro') drawLevelIntro();
    if (state.phase === 'gameover') drawGameOver();

    drawCockpitVignette();

    if (state.phase === 'paused') {
      ctx.fillStyle = 'rgba(5, 8, 22, 0.78)';
      ctx.fillRect(0, 0, state.w, state.h);
      ctx.fillStyle = '#eaf2ff';
      ctx.font = `bold ${Math.floor(48 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSE', state.w/2, state.h/2 - 30*state.dpr);
      ctx.font = `${Math.floor(18 * state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
      ctx.fillStyle = '#b9d6ff';
      ctx.fillText('Tippe ‚ÄûWeiter‚Äú unten', state.w/2, state.h/2 + 20*state.dpr);
    }

    if (state.shakeT > 0) ctx.restore();
  }

  function loop(t) {
    if (!state.lastT) state.lastT = t;
    const dt = clamp(t - state.lastT, 0, 34);
    state.lastT = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  let lastTouch = 0;
  document.addEventListener('touchend', (e) => {
    if (Date.now() - lastTouch <= 300) e.preventDefault();
    lastTouch = Date.now();
  }, { passive: false });
})();
</script>
</body>
</html>
