<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>SpaceMathe ‚Äì Einmaleins im Hyperdrive</title>
  <style>
    :root{
      --bg:#050816; --panel:#0b1230; --txt:#eaf2ff; --muted:#b9d6ff; --accent:#5ad6ff;
      --danger:#ff5b7a; --ok:#1fe3a2;
    }
    html, body { margin:0; padding:0; height:100%; background:var(--bg); overflow:hidden; touch-action:manipulation; }
    canvas { display:block; width:100vw; height:100vh; }
    * { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }

    /* Overlay UI */
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      padding:20px; box-sizing:border-box;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(90,214,255,.10), rgba(5,8,22,.92));
      color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Arial;
    }
    .card{
      width:min(520px, 92vw);
      background: rgba(11,18,48,.92);
      border: 1px solid rgba(127,168,255,.25);
      border-radius: 18px;
      padding: 18px 16px;
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
    }
    .title{
      font-size: 34px; font-weight: 800; letter-spacing:.2px;
      display:flex; gap:10px; align-items:center; justify-content:center;
      margin: 6px 0 2px;
    }
    .subtitle{
      text-align:center; color:var(--muted); margin: 0 0 12px; font-size: 15px;
    }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin: 10px 0; }
    .row label{ font-size: 15px; color:var(--txt); }
    .row .val{ font-variant-numeric: tabular-nums; color:var(--accent); min-width: 56px; text-align:right; }
    input[type="range"]{ width: 62%; }
    select, button{
      font: inherit; border-radius: 12px; border: 1px solid rgba(127,168,255,.28);
      background: rgba(5,8,22,.75); color: var(--txt); padding: 10px 12px;
    }
    button{
      width:100%; margin-top: 12px; background: rgba(90,214,255,.18);
      border-color: rgba(90,214,255,.35);
      font-weight: 700;
      padding: 12px 14px;
    }
    button:active{ transform: translateY(1px); }
    .chips{
      display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top: 10px;
    }
    .chip{
      font-size: 12px; color: var(--muted);
      border: 1px solid rgba(127,168,255,.22);
      border-radius: 999px; padding: 6px 10px;
      background: rgba(5,8,22,.55);
    }
    .tiny{ text-align:center; color:#6c85c7; font-size: 12px; margin-top: 10px; }
    .hidden{ display:none !important; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="menu" class="overlay">
  <div class="card">
    <div class="title">üöÄ SpaceMathe</div>
    <p class="subtitle">Einmaleins √ºben wie ein Arcade‚ÄëGame. Stell‚Äôs erst gem√ºtlich ein üôÇ</p>

    <div class="row">
      <label for="speed">Speed</label>
      <input id="speed" type="range" min="1" max="10" step="1" value="3" />
      <div class="val" id="speedVal">3/10</div>
    </div>

    <div class="row">
      <label for="answers">Antworten</label>
      <select id="answers">
        <option value="3">3 Antworten</option>
        <option value="4">4 Antworten</option>
      </select>
      <div class="val" id="answersVal">3</div>
    </div>

    <div class="row">
      <label for="maxFactor">Reihen bis</label>
      <input id="maxFactor" type="range" min="2" max="10" step="1" value="4" />
      <div class="val" id="maxFactorVal">4</div>
    </div>

    <div class="row">
      <label for="ramp">Steigerung</label>
      <select id="ramp">
        <option value="on" selected>an (wird schwerer)</option>
        <option value="off">aus (bleibt so)</option>
      </select>
      <div class="val" id="rampVal">an</div>
    </div>

    <div class="chips">
      <span class="chip">‚úÖ richtig = Warp‚ÄëBoost</span>
      <span class="chip">‚ùå falsch/zu sp√§t = Schild‚ÄëTreffer</span>
      <span class="chip">‚≠ê Bestwert wird gespeichert</span>
    </div>

    <button id="startBtn">Start</button>
    <div class="tiny">Tipp: Safari ‚Üí Teilen ‚Üí ‚ÄûZum Home‚ÄëBildschirm‚Äú</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Menu elements
  const menu = document.getElementById('menu');
  const speedEl = document.getElementById('speed');
  const answersEl = document.getElementById('answers');
  const maxFactorEl = document.getElementById('maxFactor');
  const rampEl = document.getElementById('ramp');
  const startBtn = document.getElementById('startBtn');
  const speedVal = document.getElementById('speedVal');
  const answersVal = document.getElementById('answersVal');
  const maxFactorVal = document.getElementById('maxFactorVal');
  const rampVal = document.getElementById('rampVal');

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));

  // --- HiDPI resize ---
  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w; canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    state.dpr = dpr;
    state.w = w; state.h = h;
  }
  window.addEventListener('resize', resize, { passive:true });

  function roundedRectPath(x,y,w,h,r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  const state = {
    w: 0, h: 0, dpr: 1,
    phase: "menu", // menu | play | gameover
    lastT: 0,
    stars: [],
    capsules: [],
    particles: [],
    shakeT: 0,
    score: 0,
    best: 0,
    combo: 0,
    shield: 3,
    wave: 0,
    task: null,

    // settings
    rampOn: true,
    baseTimeLimit: 5200, // ms, will be derived from speed slider
    baseSpeed: 0.30,     // px/ms, derived from speed slider
    optionCount: 3,
    startMaxFactor: 4,

    // runtime difficulty
    maxFactor: 4,
    timeLimit: 5200,
    speed: 0.30,
    recent: [],
    ship: { x: 0, y: 0, r: 26 }
  };

  try { state.best = Number(localStorage.getItem('spacemathe_best')||0) || 0; } catch(e){}

  resize();

  function initStars() {
    state.stars.length = 0;
    const n = Math.floor((state.w*state.h) / (220000));
    const count = clamp(n, 80, 220);
    for (let i=0;i<count;i++) {
      state.stars.push({
        x: Math.random()*state.w,
        y: Math.random()*state.h,
        z: rand(0.2, 1.0),
        s: rand(0.7, 2.2) * state.dpr
      });
    }
  }
  initStars();
  window.addEventListener('resize', initStars, { passive:true });

  function placeShip() {
    state.ship.x = state.w*0.5;
    state.ship.y = state.h - (88 * state.dpr);
    state.ship.r = 26 * state.dpr;
  }
  placeShip();
  window.addEventListener('resize', placeShip, { passive:true });

  // --- Settings mapping (make slow by default) ---
  function applySettingsFromUI() {
    const speed = Number(speedEl.value);        // 1..10
    const options = Number(answersEl.value);    // 3..4
    const maxF = Number(maxFactorEl.value);     // 2..10
    const rampOn = rampEl.value === "on";

    // Speed slider maps to time limit + movement:
    // speed 1 => very slow (6500ms), speed 10 => fast (2500ms)
    const tl = 6500 - (speed-1) * (4000/9); // linear 6500..2500
    // baseSpeed used as lower bound when travel/time yields too low speed
    const bs = 0.22 + (speed-1) * (0.28/9); // 0.22..0.50 px/ms (before dpr scaling)

    state.baseTimeLimit = tl;
    state.baseSpeed = bs;
    state.optionCount = options;
    state.startMaxFactor = maxF;
    state.rampOn = rampOn;
  }

  function updateMenuLabels() {
    speedVal.textContent = `${speedEl.value}/10`;
    answersVal.textContent = answersEl.value;
    maxFactorVal.textContent = maxFactorEl.value;
    rampVal.textContent = (rampEl.value === "on") ? "an" : "aus";
  }

  [speedEl, answersEl, maxFactorEl, rampEl].forEach(el => {
    el.addEventListener('input', () => { applySettingsFromUI(); updateMenuLabels(); }, { passive:true });
    el.addEventListener('change', () => { applySettingsFromUI(); updateMenuLabels(); }, { passive:true });
  });

  applySettingsFromUI();
  updateMenuLabels();

  // --- Task generator (classic 1x1) ---
  function pickTask() {
    const maxF = state.maxFactor;
    let a = randi(1, maxF);
    let b = randi(1, maxF);
    if (maxF >= 5) {
      if (Math.random() < 0.25) a = randi(2, maxF);
      if (Math.random() < 0.25) b = randi(2, maxF);
    }
    const ans = a*b;
    return { a, b, ans, text: `${a} √ó ${b}` };
  }

  function makeOptions(correct) {
    const opts = new Set([correct]);
    const plausible = [
      correct + randi(-3,3),
      correct + randi(-5,5),
      correct + randi(-10,10),
      (correct + randi(-2,2)) * (Math.random()<0.5 ? 1 : -1),
    ];
    if (state.task) {
      const {a,b} = state.task;
      plausible.push((clamp(a-1,1,10))*b);
      plausible.push((clamp(a+1,1,10))*b);
      plausible.push(a*(clamp(b-1,1,10)));
      plausible.push(a*(clamp(b+1,1,10)));
      plausible.push((a*b)+1);
      plausible.push((a*b)-1);
    }
    const pickPlausible = () => {
      let v = plausible[randi(0, plausible.length-1)];
      if (!Number.isFinite(v)) v = correct + randi(-9,9);
      v = Math.abs(Math.round(v));
      v = clamp(v, 0, 100);
      if (v === correct && Math.random() < 0.7) v = clamp(correct + randi(-9,9), 0, 100);
      return v;
    };
    while (opts.size < state.optionCount) {
      let v = pickPlausible();
      if (v === correct) continue;
      opts.add(v);
    }
    const arr = Array.from(opts);
    for (let i=arr.length-1;i>0;i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function spawnWave() {
    state.wave++;
    state.task = pickTask();
    const options = makeOptions(state.task.ans);

    const topY = -80 * state.dpr;
    const shipY = state.ship.y;
    const travel = shipY - topY;

    const baseV = travel / state.timeLimit; // px/ms
    const v = Math.max(baseV, state.speed);

    state.capsules.length = 0;
    const count = options.length;

    const marginX = 44 * state.dpr;
    const minX = marginX;
    const maxX = state.w - marginX;
    const step = (maxX - minX) / (count);

    for (let i=0;i<count;i++) {
      const laneCenter = minX + step*(i + 0.5);
      const jitter = rand(-18, 18) * state.dpr;
      const x = clamp(laneCenter + jitter, minX, maxX);
      state.capsules.push({
        x, y: topY,
        r: (32 + (count===4? -2:0)) * state.dpr,
        value: options[i],
        correct: options[i] === state.task.ans,
        vy: v * rand(0.95, 1.08),
      });
    }
  }

  function burst(x,y,good=true) {
    const n = good ? 36 : 18;
    for (let i=0;i<n;i++) {
      const a = Math.random()*Math.PI*2;
      const sp = (good ? rand(0.25, 1.05) : rand(0.2,0.8)) * state.dpr;
      state.particles.push({
        x, y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: good ? rand(420, 820) : rand(320, 620),
        t: 0,
        good
      });
    }
  }
  function screenShake(intensityMs=260) { state.shakeT = intensityMs; }

  function recordResult(ok) {
    state.recent.push(ok);
    if (state.recent.length > 12) state.recent.shift();
  }

  // Progression: only if rampOn
  function updateDifficulty() {
    if (!state.rampOn) return;

    const w = state.wave;

    // Increase factor range gradually up to 10, but start from chosen max
    const base = state.startMaxFactor;
    // Slowly expand beyond base if base < 10
    const extra = (w>=10 ? 1 : 0) + (w>=18 ? 1 : 0) + (w>=28 ? 1 : 0) + (w>=40 ? 1 : 0) + (w>=54 ? 1 : 0) + (w>=70 ? 1 : 0);
    state.maxFactor = clamp(base + extra, 2, 10);

    // If user selected 3 answers, switch to 4 later (but never before wave 12)
    if (state.optionCount === 3 && w >= 14) state.optionCount = 4;

    // Tighten time limit mildly (keep friendly)
    const target = state.baseTimeLimit - w*18; // ms
    state.timeLimit = clamp(target, 2600, state.baseTimeLimit);

    // Increase speed mildly
    state.speed = clamp((state.baseSpeed + w*0.0018), 0.18, 0.80) * state.dpr;

    // Adaptive easing/hardening
    const r = state.recent;
    if (r.length >= 8) {
      const acc = r.filter(Boolean).length / r.length;
      if (acc < 0.60) {
        state.timeLimit = clamp(state.timeLimit + 360, 2800, state.baseTimeLimit + 600);
        if (state.optionCount === 4 && w < 20) state.optionCount = 3;
      } else if (acc > 0.90) {
        state.timeLimit = clamp(state.timeLimit - 220, 2400, state.baseTimeLimit);
        if (w >= 18) state.optionCount = 4;
      }
    }
  }

  function resetGame() {
    state.score = 0;
    state.combo = 0;
    state.shield = 3;
    state.wave = 0;
    state.recent.length = 0;
    state.capsules.length = 0;
    state.particles.length = 0;

    // apply chosen settings into runtime values
    state.maxFactor = state.startMaxFactor;
    state.timeLimit = state.baseTimeLimit;
    state.speed = state.baseSpeed * state.dpr;

    state.phase = "play";
    placeShip();
    spawnWave();
  }

  function gameOver() {
    state.phase = "gameover";
    state.capsules.length = 0;
    state.combo = 0;
    if (state.score > state.best) {
      state.best = state.score;
      try { localStorage.setItem('spacemathe_best', String(state.best)); } catch(e){}
    }
  }

  // --- Input ---
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * state.dpr;
    const y = (e.clientY - rect.top) * state.dpr;
    return {x,y};
  }

  function handleTap(x,y) {
    if (state.phase === "play") {
      for (let i=0;i<state.capsules.length;i++) {
        const c = state.capsules[i];
        const dx = x - c.x, dy = y - c.y;
        if (dx*dx + dy*dy <= c.r*c.r) {
          if (c.correct) {
            burst(c.x, c.y, true);
            state.score += 10 + state.combo*2;
            state.combo++;
            recordResult(true);
            for (const other of state.capsules) burst(other.x, other.y, true);
            state.capsules.length = 0;
            updateDifficulty();
            spawnWave();
          } else {
            burst(c.x, c.y, false);
            recordResult(false);
            state.combo = 0;
            state.shield -= 1;
            screenShake(320);
            if (state.shield <= 0) gameOver();
            else {
              state.capsules.length = 0;
              updateDifficulty();
              spawnWave();
            }
          }
          return;
        }
      }
    } else if (state.phase === "gameover") {
      // back to menu on tap anywhere
      state.phase = "menu";
      menu.classList.remove('hidden');
    }
  }

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    const p = getPointerPos(e);
    handleTap(p.x, p.y);
  }, { passive:false });

  // Menu Start
  startBtn.addEventListener('click', (e) => {
    e.preventDefault();
    applySettingsFromUI();
    updateMenuLabels();
    menu.classList.add('hidden');
    resetGame();
  }, { passive:false });

  // --- Update loop ---
  function update(dt) {
    // starfield
    for (const s of state.stars) {
      s.y += (0.03 + 0.18*s.z) * dt * state.dpr;
      if (s.y > state.h + 10) { s.y = -10; s.x = Math.random()*state.w; }
    }

    // particles
    for (let i=state.particles.length-1;i>=0;i--) {
      const p = state.particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.995;
      p.vy *= 0.995;
      if (p.t > p.life) state.particles.splice(i,1);
    }

    if (state.phase === "play") {
      const shipY = state.ship.y;
      for (let i=state.capsules.length-1;i>=0;i--) {
        const c = state.capsules[i];
        c.y += c.vy * dt;

        // collision / timeout
        if (c.y + c.r >= shipY - state.ship.r*0.25) {
          recordResult(false);
          state.combo = 0;
          state.shield -= 1;
          screenShake(380);
          burst(c.x, shipY - state.ship.r, false);

          state.capsules.length = 0;
          if (state.shield <= 0) gameOver();
          else { updateDifficulty(); spawnWave(); }
          break;
        }
      }
    }

    if (state.shakeT > 0) state.shakeT = Math.max(0, state.shakeT - dt);
  }

  // --- Render ---
  function drawHeart(cx, cy, r) {
    ctx.fillStyle = '#ff5b7a';
    ctx.beginPath();
    const x = cx, y = cy;
    ctx.moveTo(x, y + r*0.35);
    ctx.bezierCurveTo(x + r*1.1, y - r*0.7, x + r*2.0, y + r*0.8, x, y + r*1.8);
    ctx.bezierCurveTo(x - r*2.0, y + r*0.8, x - r*1.1, y - r*0.7, x, y + r*0.35);
    ctx.fill();
  }

  function drawHUD() {
    const pad = 16*state.dpr;
    const top = 10*state.dpr;

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#0b1230';
    roundedRectPath(pad, top, state.w - pad*2, 86*state.dpr, 16*state.dpr);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Task
    ctx.fillStyle = '#eaf2ff';
    ctx.font = `${Math.floor(34*state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const taskText = (state.phase === "play" && state.task) ? `${state.task.text} = ?` : `SpaceMathe`;
    ctx.fillText(taskText, pad*1.6, top + 43*state.dpr);

    // hearts
    const hx = state.w - pad*1.6;
    const hy = top + 43*state.dpr;
    const r = 10*state.dpr;
    for (let i=0;i<3;i++) {
      const x = hx - i*(26*state.dpr);
      ctx.globalAlpha = (i < state.shield) ? 1 : 0.25;
      drawHeart(x, hy, r);
    }
    ctx.globalAlpha = 1;

    // score / combo
    ctx.fillStyle = '#b9d6ff';
    ctx.font = `${Math.floor(18*state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    const comboText = state.combo >= 2 ? `Combo x${state.combo}` : '';
    ctx.fillText(`Score ${state.score}` + (comboText ? `   ‚Ä¢   ${comboText}` : ''), pad*1.6, top + 78*state.dpr);

    // right hints
    ctx.textAlign = 'right';
    ctx.fillStyle = '#7fa8ff';
    const mode = state.rampOn ? 'Steigerung an' : 'Steigerung aus';
    ctx.fillText(`Reihen bis ${state.maxFactor} ‚Ä¢ ${state.optionCount} Antworten ‚Ä¢ ${mode}`, state.w - pad*1.6, top + 78*state.dpr);
    ctx.textAlign = 'left';
  }

  function drawShip() {
    const {x,y,r} = state.ship;

    // glow
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#5ad6ff';
    ctx.beginPath();
    ctx.arc(x, y, r*1.35, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // body
    ctx.fillStyle = '#eaf2ff';
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.lineTo(x + r*0.9, y + r*0.9);
    ctx.lineTo(x, y + r*0.45);
    ctx.lineTo(x - r*0.9, y + r*0.9);
    ctx.closePath();
    ctx.fill();

    // cockpit
    ctx.fillStyle = '#0b1230';
    ctx.beginPath();
    ctx.arc(x, y - r*0.15, r*0.35, 0, Math.PI*2);
    ctx.fill();

    // flame based on combo
    const flame = clamp(6 + state.combo*1.2, 6, 18) * state.dpr;
    ctx.fillStyle = '#ffd36a';
    ctx.beginPath();
    ctx.moveTo(x, y + r*0.9);
    ctx.lineTo(x + r*0.25, y + r*0.9 + flame);
    ctx.lineTo(x, y + r*0.9 + flame*0.7);
    ctx.lineTo(x - r*0.25, y + r*0.9 + flame);
    ctx.closePath();
    ctx.fill();
  }

  function drawCapsule(c) {
    ctx.globalAlpha = 0.96;
    ctx.fillStyle = '#2b4cff';
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#0b1230';
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r*0.82, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#eaf2ff';
    ctx.font = `${Math.floor(c.r*0.9)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(c.value), c.x, c.y + 1*state.dpr);

    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(c.x - c.r*0.25, c.y - c.r*0.3, c.r*0.35, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawGameOver() {
    const cx = state.w/2, cy = state.h/2;
    ctx.fillStyle = '#eaf2ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.font = `${Math.floor(44*state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillText('üí• GAME OVER', cx, cy - 78*state.dpr);

    ctx.font = `${Math.floor(22*state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillStyle = '#b9d6ff';
    ctx.fillText(`Score: ${state.score}`, cx, cy - 20*state.dpr);
    ctx.fillText(`Best: ${state.best}`, cx, cy + 16*state.dpr);

    ctx.fillStyle = '#7fa8ff';
    ctx.font = `${Math.floor(16*state.dpr)}px system-ui, -apple-system, Segoe UI, Arial`;
    ctx.fillText('Tippe ‚Üí zur√ºck zum Startbildschirm', cx, cy + 66*state.dpr);
  }

  function draw() {
    ctx.fillStyle = '#050816';
    ctx.fillRect(0,0,state.w,state.h);

    if (state.shakeT > 0) {
      const k = state.shakeT / 380;
      const sx = (Math.random()*2-1) * 10 * k * state.dpr;
      const sy = (Math.random()*2-1) * 10 * k * state.dpr;
      ctx.save();
      ctx.translate(sx, sy);
      drawWorld();
      ctx.restore();
    } else {
      drawWorld();
    }
  }

  function drawWorld() {
    // stars
    ctx.fillStyle = '#cfe3ff';
    for (const s of state.stars) {
      const a = 0.25 + 0.55*s.z;
      ctx.globalAlpha = a;
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }
    ctx.globalAlpha = 1;

    // HUD + entities
    drawHUD();
    drawShip();
    for (const c of state.capsules) drawCapsule(c);

    // particles
    for (const p of state.particles) {
      const t = p.t / p.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = p.good ? '#9cffd8' : '#ff7a7a';
      ctx.beginPath();
      ctx.arc(p.x, p.y, (2.2 + (p.good?1.2:0.8)) * state.dpr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    if (state.phase === "gameover") drawGameOver();
  }

  // --- Main loop ---
  function loop(t) {
    if (!state.lastT) state.lastT = t;
    const dt = clamp(t - state.lastT, 0, 34);
    state.lastT = t;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // iOS: prevent double-tap zoom
  let lastTouch = 0;
  document.addEventListener('touchend', (e) => {
    const t = Date.now();
    if (t - lastTouch <= 300) e.preventDefault();
    lastTouch = t;
  }, { passive:false });

})();
</script>
</body>
</html>
